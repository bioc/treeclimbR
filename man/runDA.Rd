% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/runDA.R
\name{runDA}
\alias{runDA}
\title{Test for differential abundance using edgeR}
\usage{
runDA(
  TSE,
  feature_on_row = TRUE,
  assay = NULL,
  option = c("glm", "glmQL"),
  design = NULL,
  contrast = NULL,
  filter_min_count = 10,
  filter_min_total_count = 15,
  filter_large_n = 10,
  filter_min_prop = 0.7,
  normalize = TRUE,
  normalize_method = "TMM",
  group_column = "group",
  design_terms = "group",
  ...
)
}
\arguments{
\item{TSE}{A TreeSummarizedExperiment object.}

\item{feature_on_row}{A logical value, TRUE or FALSE. If TRUE (default),
features or entities (e.g. genes, OTUs) are in rows of the \code{assays}
tables, and samples are in columns; otherwise, the other way around.}

\item{assay}{A numeric value to specify which table from \code{assays} is
used for analysis.}

\item{option}{\code{"glm"} or \code{"glmQL"}. If \code{"glm"},
\code{\link[edgeR]{glmFit}} and \code{\link[edgeR]{glmLRT}} are used;
otherwise, \code{\link[edgeR]{glmQLFit}} and
\code{\link[edgeR]{glmQLFTest}} are used. Details about the difference
between two options are in the help page of \code{\link[edgeR]{glmQLFit}}.}

\item{design}{A numeric matrix. It must be of full column rank. Defaults to
use all columns of sample annotation data to create the design matrix. The
sample annotation data is stored in the \code{colData} of \code{tse} when
\code{onRow = TRUE}; otherwise it is in the \code{rowData}. Note: Users
should check whether the default created design matrix is exactly what they
want or create their own design matrix using
\code{\link[stats]{model.matrix}}.}

\item{contrast}{A numeric vector specifying one contrast of
the linear model coefficients to be tested equal to zero. Its length
must equal to the number of columns of design. If NULL, the last
coefficient will be tested equal to zero.}

\item{filter_min_count}{A numeric value. It's passed to \strong{min.count} of
\code{\link[edgeR]{filterByExpr}}.}

\item{filter_min_total_count}{A numeric value. It's passed to
\strong{min.total.count} of \code{\link[edgeR]{filterByExpr}}.}

\item{filter_large_n}{A numeric value. It's passed to \strong{large.n} of
\code{\link[edgeR]{filterByExpr}}.}

\item{filter_min_prop}{A numeric value. It's passed to \strong{min.prop} of
\code{\link[edgeR]{filterByExpr}}.}

\item{normalize}{A logical value, TRUE or FALSE. The default is TRUE.}

\item{normalize_method}{Normalization method to be used. See
\code{\link[edgeR]{calcNormFactors}} for more details.
It could be "bonferroni", "holm", "hochberg", "hommel", "BH", or "BY". This
is passed to \code{adjust.method} of \code{\link[edgeR]{topTags}}}

\item{group_column}{The column name of group}

\item{design_terms}{The names of columns from \code{colData} (if samples in
columns) that are used to generate design matrix. This is ignored if
\strong{design} is provided.}

\item{...}{More arguments to pass to \code{\link[edgeR]{glmFit}}
(\code{option = "glm"} or \code{\link[edgeR]{glmQLFit}} (\code{option =
"glmQL"}).}
}
\value{
a list includes \strong{edgeR_results}, \strong{tree}, and
  \strong{nodes_drop}.
\describe{
  \item{edgeR_results}{The output of \code{\link[edgeR]{glmQLFTest}} or
     \code{\link[edgeR]{glmLRT}} depends on the specified \code{option}.}
  \item{tree}{The hiearchical structure of entities that was stored in the
     input \code{tse}}
  \item{nodes_drop}{A vector storing the alias node labels of entities.
     These entities are filtered before analysis due to low counts. }
}
}
\description{
\code{runDA} tests differential abundance of entities using functions from
the \code{\link{edgeR}}. This adapts \code{\link{edgerWrp}} to accept input
as a \code{\link[TreeSummarizedExperiment]{TreeSummarizedExperiment}}
(\strong{TSE}) object instead of \code{matrix}. To clarify, the count table
is stored in the \code{assays} table of \strong{TSE} object. Features could
be stored either in rows or columns. Here, we consider features are in rows.
Then, samples are in columns and the sample information is in \code{colData}.
The tree that stores the hierarchical information about features is in
\code{rowTree}. Each row of \code{assays} table could be mapped to a node of
the tree. Data on rows that are mapped to internal nodes is generated from
data on leaf nodes. Normalization for samples is automatically performed by
\code{edgeR} package and the library size is calculated using features that
are mapped to leaf nodes. More details are in Vignette.
}
\details{
The experimental design is specified by a design matrix and provide to model
via the argument \code{design}. More details about the calculation of
normalization factor could be found from
\code{\link[edgeR]{calcNormFactors}}.
}
\examples{
library(TreeSummarizedExperiment)
library(treeclimbR)
set.seed(1)
count <- matrix(rnbinom(300,size=1,mu=10),nrow=10)
colnames(count) <- paste(rep(LETTERS[1:3], each = 10),
                         rep(1:10, 3), sep = "_")
rownames(count) <- tinyTree$tip.label
count[1, ] <- 0
rowInf <- DataFrame(var1 = sample(letters[1:3], 10, replace = TRUE),
                    var2 = sample(c(TRUE, FALSE), 10, replace = TRUE))
colInf <- DataFrame(gg = factor(sample(1:3, 30, replace = TRUE)),
                    group = rep(LETTERS[1:3], each = 10))
lse <- TreeSummarizedExperiment(assays = list(count),
                                rowData = rowInf,
                                colData = colInf,
                                rowTree = tinyTree)
nodes <- showNode(tree = tinyTree, only.leaf = FALSE)
tse <- aggTSE(x = lse, rowLevel = nodes)

dd <- model.matrix( ~ group, data = colInf)
out <- runDA(TSE = tse, feature_on_row = TRUE,
             assay = 1, option = "glmQL",
             design = dd, contrast = NULL,
             normalize = TRUE,
             group_column = "group")
}
\author{
Ruizhu Huang
}
